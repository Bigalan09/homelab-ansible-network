---
- name: Configure Garage Router (Gateway baseline)
  hosts: gateway
  become: false
  gather_facts: false

  vars_files:
    - group_vars/all/network.yml
    - group_vars/all/vault.yml

  vars:
    lan_ip: "10.1.0.1"
    lan_netmask: "255.255.255.0"
    garage_mgmt_ssid_default: "homelab_garage_mngmt"
    garage_wifi_radios_to_disable_default:
      - radio0
      - radio1
    garage_test_mode_default: false
    garage_test_repeater_network_default: "wwan"
    garage_test_repeater_radio_default: "radio1"
    garage_test_repeater_encryption_default: "sae"
    garage_test_repeater_radios_default:
      - "radio1"
      - "radio0"
      - "radio2"
    garage_test_repeater_encryptions_default:
      - "sae"
      - "sae-mixed"
      - "psk2"
      - "psk-mixed"
    garage_test_tailscale_hosts_default:
      - "login.tailscale.com"
      - "api.tailscale.com"
    garage_test_uplink_wait_seconds_default: 90
    garage_test_uplink_poll_interval_seconds_default: 5
    tailscale_enable_default: true
    tailscale_advertise_routes_default:
      - "10.10.0.0/24"
      - "10.20.0.0/24"
    tailscale_oauth_tailnet_default: "-"
    tailscale_oauth_tags_default:
      - "tag:router-garage"
    tailscale_oauth_key_expiry_seconds_default: 7776000
    garage_wan_proto_default: "pppoe"
    garage_wan_pppoe_mtu_default: "1492"
    garage_wan_vlan_tag_default: "911"

  tasks:
    - name: Resolve garage Wi-Fi policy
      ansible.builtin.set_fact:
        garage_mgmt_ssid_effective: "{{ garage_mgmt_ssid | default(garage_mgmt_ssid_default) }}"
        garage_wifi_radios_to_disable_effective: "{{ garage_wifi_radios_to_disable | default(garage_wifi_radios_to_disable_default) }}"
        garage_test_mode_effective: "{{ garage_test_mode | default(garage_test_mode_default) }}"
        garage_test_repeater_network_effective: "{{ garage_test_repeater_network | default(garage_test_repeater_network_default) }}"
        garage_test_repeater_radio_effective: "{{ garage_test_repeater_radio | default(garage_test_repeater_radio_default) }}"
        garage_test_repeater_encryption_effective: "{{ garage_test_repeater_encryption | default(garage_test_repeater_encryption_default) }}"
        garage_test_repeater_radios_effective: "{{ garage_test_repeater_radios | default(garage_test_repeater_radios_default) }}"
        garage_test_repeater_encryptions_effective: "{{ garage_test_repeater_encryptions | default(garage_test_repeater_encryptions_default) }}"
        garage_test_tailscale_hosts_effective: "{{ garage_test_tailscale_hosts | default(garage_test_tailscale_hosts_default) }}"
        garage_test_uplink_wait_seconds_effective: "{{ garage_test_uplink_wait_seconds | default(garage_test_uplink_wait_seconds_default) }}"
        garage_test_uplink_poll_interval_seconds_effective: "{{ garage_test_uplink_poll_interval_seconds | default(garage_test_uplink_poll_interval_seconds_default) }}"
        garage_test_repeater_ssid_effective: "{{ garage_test_repeater_ssid | default(vault_garage_test_repeater_ssid | default('')) }}"
        garage_test_repeater_password_effective: "{{ garage_test_repeater_password | default(vault_garage_test_repeater_password | default('')) }}"
        tailscale_enable_effective: "{{ tailscale_enable | default(tailscale_enable_default) }}"
        tailscale_advertise_routes_effective: "{{ tailscale_advertise_routes | default(tailscale_advertise_routes_default) }}"
        tailscale_advertise_routes_csv: "{{ (tailscale_advertise_routes | default(tailscale_advertise_routes_default)) | join(',') }}"
        tailscale_auth_key_effective: "{{ tailscale_auth_key | default('') }}"
        tailscale_oauth_client_id_effective: "{{ tailscale_oauth_client_id | default(vault_tailscale_oauth_client_id | default('')) }}"
        tailscale_oauth_client_secret_effective: "{{ tailscale_oauth_client_secret | default(vault_tailscale_oauth_client_secret | default('')) }}"
        tailscale_oauth_tailnet_effective: "{{ tailscale_oauth_tailnet | default(tailscale_oauth_tailnet_default) }}"
        tailscale_oauth_tags_effective: "{{ tailscale_oauth_tags | default(tailscale_oauth_tags_default) }}"
        tailscale_oauth_key_expiry_seconds_effective: "{{ tailscale_oauth_key_expiry_seconds | default(tailscale_oauth_key_expiry_seconds_default) }}"
        tailscale_generated_auth_key_effective: ""
        garage_wan_proto_effective: "{{ garage_wan_proto | default(garage_wan_proto_default) }}"
        garage_wan_pppoe_mtu_effective: "{{ garage_wan_pppoe_mtu | default(garage_wan_pppoe_mtu_default) }}"
        garage_wan_vlan_tag_effective: "{{ garage_wan_vlan_tag | default(garage_wan_vlan_tag_default) }}"
        garage_wan_parent_if_effective: "{{ garage_wan_parent_if | default('') }}"
        garage_wan_pppoe_service_effective: "{{ garage_wan_pppoe_service | default('') }}"
        garage_wan_pppoe_username_effective: "{{ garage_wan_pppoe_username | default(vault_garage_wan_pppoe_username | default('')) }}"
        garage_wan_pppoe_password_effective: "{{ garage_wan_pppoe_password | default(vault_garage_wan_pppoe_password | default('')) }}"

    - name: Validate PPPoE credentials are available
      ansible.builtin.assert:
        that:
          - garage_wan_pppoe_username_effective | length > 0
          - garage_wan_pppoe_password_effective | length > 0
          - garage_wan_vlan_tag_effective | length > 0
        fail_msg: >-
          garage_wan_proto is pppoe but PPPoE requirements are missing.
          Set vault_garage_wan_pppoe_username and
          vault_garage_wan_pppoe_password in group_vars/all/vault.yml,
          and set garage_wan_vlan_tag (e.g. 911) in network.yml.
      when:
        - garage_wan_proto_effective == "pppoe"
        - not (garage_test_mode_effective | bool)

    - name: Validate test-mode repeater credentials are available
      ansible.builtin.assert:
        that:
          - garage_test_repeater_ssid_effective | length > 0
          - garage_test_repeater_password_effective | length > 0
        fail_msg: >-
          garage_test_mode is enabled but repeater credentials are missing.
          Set vault_garage_test_repeater_ssid and
          vault_garage_test_repeater_password in group_vars/all/vault.yml.
      when: garage_test_mode_effective | bool

    - name: Set router hostname and timezone
      ansible.builtin.raw: |
        uci set system.@system[0].hostname='router-garage'
        uci set system.@system[0].zonename='Europe/London'
        uci set system.@system[0].timezone='GMT0BST,M3.5.0/1,M10.5.0'

    - name: Rename garage Wi-Fi SSIDs to management label
      ansible.builtin.raw: |
        idx=0
        while uci -q get wireless.@wifi-iface[$idx] >/dev/null 2>&1; do
          uci set wireless.@wifi-iface[$idx].ssid='{{ garage_mgmt_ssid_effective }}'
          idx=$((idx+1))
        done

    - name: Set LAN management interface
      ansible.builtin.raw: |
        uci set network.lan.ipaddr='{{ lan_ip }}'
        uci set network.lan.netmask='{{ lan_netmask }}'

    - name: Configure WAN VLAN device for PPPoE
      ansible.builtin.raw: |
        current_wan_dev="$(uci -q get network.wan.device || true)"
        wan_parent='{{ garage_wan_parent_if_effective }}'
        if [ -z "$wan_parent" ]; then
          if [ -n "$current_wan_dev" ]; then
            case "$current_wan_dev" in
              *.*) wan_parent="${current_wan_dev%%.*}" ;;
              *) wan_parent="$current_wan_dev" ;;
            esac
          else
            wan_parent='eth1'
          fi
        fi
        wan_vlan_dev="${wan_parent}.{{ garage_wan_vlan_tag_effective }}"
        uci -q delete network.wan_vlan
        uci set network.wan_vlan='device'
        uci set network.wan_vlan.type='8021q'
        uci set network.wan_vlan.ifname="$wan_parent"
        uci set network.wan_vlan.vid='{{ garage_wan_vlan_tag_effective }}'
        uci set network.wan_vlan.name="$wan_vlan_dev"
        uci set network.wan.device="$wan_vlan_dev"
      when:
        - garage_wan_proto_effective == "pppoe"
        - not (garage_test_mode_effective | bool)

    - name: Configure WAN PPPoE credentials and behavior
      ansible.builtin.raw: |
        uci set network.wan.proto='pppoe'
        uci set network.wan.username='{{ garage_wan_pppoe_username_effective }}'
        uci set network.wan.password='{{ garage_wan_pppoe_password_effective }}'
        uci set network.wan.mtu='{{ garage_wan_pppoe_mtu_effective }}'
        uci set network.wan.ipv6='auto'
        uci set network.wan.peerdns='1'
        {% if garage_wan_pppoe_service_effective | length > 0 %}
        uci set network.wan.service='{{ garage_wan_pppoe_service_effective }}'
        {% endif %}
      when:
        - garage_wan_proto_effective == "pppoe"
        - not (garage_test_mode_effective | bool)
      no_log: true

    - name: Configure test-mode repeater uplink (Wi-Fi WAN)
      ansible.builtin.raw: |
        uci -q delete network.{{ garage_test_repeater_network_effective }}
        uci set network.{{ garage_test_repeater_network_effective }}='interface'
        uci set network.{{ garage_test_repeater_network_effective }}.proto='dhcp'
        uci set network.{{ garage_test_repeater_network_effective }}.peerdns='1'
        uci set network.{{ garage_test_repeater_network_effective }}.metric='10'

        ssid={{ garage_test_repeater_ssid_effective | quote }}
        selected_radio='{{ garage_test_repeater_radio_effective }}'
        for radio in {{ garage_test_repeater_radios_effective | join(' ') }}; do
          uci -q get wireless."$radio" >/dev/null 2>&1 || continue
          if iwinfo "$radio" scan 2>/dev/null | grep -F "ESSID: \"$ssid\"" >/dev/null 2>&1; then
            selected_radio="$radio"
            break
          fi
        done
        if ! uci -q get wireless."$selected_radio" >/dev/null 2>&1; then
          for radio in {{ garage_test_repeater_radios_effective | join(' ') }}; do
            if uci -q get wireless."$radio" >/dev/null 2>&1; then
              selected_radio="$radio"
              break
            fi
          done
        fi
        if ! uci -q get wireless."$selected_radio" >/dev/null 2>&1; then
          selected_radio="$(uci -q show wireless | sed -n "s/^wireless\\.\\([^.=]*\\)=wifi-device$/\\1/p" | head -n 1)"
        fi
        [ -n "$selected_radio" ] || selected_radio='radio0'
        if ! uci -q get wireless."$selected_radio" >/dev/null 2>&1; then
          echo "No usable wifi-device section found in wireless UCI config."
          uci -q show wireless || true
          exit 11
        fi

        uci set wireless."$selected_radio".disabled='0'
        uci -q delete wireless.sta
        uci set wireless.sta='wifi-iface'
        uci set wireless.sta.device="$selected_radio"
        uci set wireless.sta.mode='sta'
        uci set wireless.sta.network='{{ garage_test_repeater_network_effective }}'
        uci set wireless.sta.ssid={{ garage_test_repeater_ssid_effective | quote }}
        uci set wireless.sta.encryption='{{ garage_test_repeater_encryption_effective }}'
        uci set wireless.sta.disabled='0'
        uci -q delete wireless.sta.wds

        idx=0
        while uci -q get firewall.@zone[$idx] >/dev/null 2>&1; do
          if [ "$(uci -q get firewall.@zone[$idx].name)" = "wan" ]; then
            uci -q del_list firewall.@zone[$idx].network='{{ garage_test_repeater_network_effective }}'
            uci add_list firewall.@zone[$idx].network='{{ garage_test_repeater_network_effective }}'
            break
          fi
          idx=$((idx+1))
        done
      when: garage_test_mode_effective | bool

    - name: Configure test-mode repeater password (secret)
      ansible.builtin.raw: |
        uci set wireless.sta.key={{ garage_test_repeater_password_effective | quote }}
      when: garage_test_mode_effective | bool
      no_log: true

    - name: Ensure VLAN interfaces exist
      ansible.builtin.raw: |
        {% for vlan in vlans %}
        uci -q delete network.vlan{{ vlan.id }}
        uci set network.vlan{{ vlan.id }}='interface'
        uci set network.vlan{{ vlan.id }}.proto='static'
        uci set network.vlan{{ vlan.id }}.device='br-lan.{{ vlan.id }}'
        uci set network.vlan{{ vlan.id }}.ipaddr='{{ vlan.ip }}'
        uci set network.vlan{{ vlan.id }}.netmask='255.255.255.0'
        {% endfor %}

    - name: Ensure DHCP pools exist for routed VLANs
      ansible.builtin.raw: |
        {% for vlan in vlans %}
        uci -q delete dhcp.vlan{{ vlan.id }}
        uci set dhcp.vlan{{ vlan.id }}='dhcp'
        uci set dhcp.vlan{{ vlan.id }}.interface='vlan{{ vlan.id }}'
        uci set dhcp.vlan{{ vlan.id }}.start='100'
        uci set dhcp.vlan{{ vlan.id }}.limit='150'
        uci set dhcp.vlan{{ vlan.id }}.leasetime='12h'
        {% endfor %}

    - name: Configure firewall zones for VLANs
      ansible.builtin.raw: |
        {% for vlan in vlans %}
        uci -q delete firewall.{{ vlan.zone }}
        uci set firewall.{{ vlan.zone }}='zone'
        uci set firewall.{{ vlan.zone }}.name='{{ vlan.zone }}'
        uci set firewall.{{ vlan.zone }}.network='vlan{{ vlan.id }}'
        uci set firewall.{{ vlan.zone }}.input='{{ 'ACCEPT' if vlan.name in ['servers', 'trusted'] else 'REJECT' }}'
        uci set firewall.{{ vlan.zone }}.output='ACCEPT'
        uci set firewall.{{ vlan.zone }}.forward='{{ 'ACCEPT' if vlan.name == 'servers' else 'REJECT' }}'
        {% endfor %}

    - name: Configure inter-zone forwarding rules from vars
      ansible.builtin.raw: |
        idx=0
        while uci -q get firewall.forwarding[$idx] >/dev/null 2>&1; do
          uci -q delete firewall.forwarding[$idx]
        done
        {% for rule in forwarding_rules %}
        uci add firewall forwarding >/dev/null
        uci set firewall.@forwarding[-1].src='{{ rule.src }}'
        uci set firewall.@forwarding[-1].dest='{{ rule.dest }}'
        {% endfor %}

    - name: Add trusted to servers limited management rule
      ansible.builtin.raw: |
        uci -q delete firewall.trusted_to_servers_mgmt
        uci set firewall.trusted_to_servers_mgmt='rule'
        uci set firewall.trusted_to_servers_mgmt.name='Trusted to Servers Web and SSH'
        uci set firewall.trusted_to_servers_mgmt.src='trusted_zone'
        uci set firewall.trusted_to_servers_mgmt.dest='server_zone'
        uci set firewall.trusted_to_servers_mgmt.proto='tcp'
        uci set firewall.trusted_to_servers_mgmt.dest_port='22 80 443'
        uci set firewall.trusted_to_servers_mgmt.target='ACCEPT'

    - name: Commit core UCI changes
      ansible.builtin.raw: |
        uci commit system
        uci commit network
        uci commit dhcp
        uci commit firewall
        uci commit wireless

    - name: Restart firewall and dnsmasq before LAN IP handoff
      ansible.builtin.raw: |
        /etc/init.d/dnsmasq restart || /etc/init.d/dnsmasq start
        /etc/init.d/firewall restart

    - name: Apply delayed network and Wi-Fi reload for safer SSH handoff
      ansible.builtin.raw: |
        nohup sh -c "sleep 2; /etc/init.d/network reload; wifi reload >/dev/null 2>&1 || true" >/dev/null 2>&1 &

    - name: Wait for SSH on post-change management IP (best effort)
      ansible.builtin.wait_for:
        host: "{{ lan_ip }}"
        port: 22
        delay: 4
        timeout: 90
      delegate_to: localhost
      become: false
      register: garage_handoff_wait
      failed_when: false
      changed_when: false

    - name: Show reconnection hint
      ansible.builtin.debug:
        msg: >-
          If your control host route changed during reload, reconnect using
          ssh root@{{ lan_ip }} and rerun with -e ansible_host=192.168.8.1 for
          future factory-reset bootstrap runs.

    - name: Reset SSH control connection after delayed reload (test mode)
      ansible.builtin.meta: reset_connection

    - name: Wait for SSH port after control-connection reset (test mode)
      ansible.builtin.wait_for:
        host: "{{ lan_ip }}"
        port: 22
        delay: 2
        timeout: 90
      delegate_to: localhost
      become: false
      changed_when: false
      when: garage_test_mode_effective | bool

    - name: "Test-mode check: verify repeater uplink internet and tailscale control-plane reachability"
      ansible.builtin.raw: |
        ifup {{ garage_test_repeater_network_effective }} >/dev/null 2>&1 || true
        elapsed=0
        uplink_up=false
        while [ "$elapsed" -lt "{{ garage_test_uplink_wait_seconds_effective | int }}" ]; do
          uplink_up="$(ifstatus {{ garage_test_repeater_network_effective }} 2>/dev/null | jsonfilter -e '@.up' 2>/dev/null || echo false)"
          [ "$uplink_up" = "true" ] && break
          sleep {{ garage_test_uplink_poll_interval_seconds_effective | int }}
          elapsed=$((elapsed + {{ garage_test_uplink_poll_interval_seconds_effective | int }}))
        done
        [ "$uplink_up" = "true" ] || exit 2

        echo "selected_radio=$(uci -q get wireless.sta.device || echo unknown)"
        echo "selected_encryption=$(uci -q get wireless.sta.encryption || echo unknown)"
        echo "uplink_wait_elapsed_seconds=$elapsed"

        ping -c1 -W3 8.8.8.8 >/dev/null 2>&1 || ping -c1 -W3 1.1.1.1 >/dev/null 2>&1 || exit 3

        {% for host in garage_test_tailscale_hosts_effective %}
        if command -v nslookup >/dev/null 2>&1; then
          nslookup {{ host }} >/dev/null 2>&1 || exit 4
        fi
        if command -v uclient-fetch >/dev/null 2>&1; then
          uclient-fetch -T 5 -qO- https://{{ host }} >/dev/null 2>&1 || exit 5
        elif command -v wget >/dev/null 2>&1; then
          wget -q -O /dev/null https://{{ host }} >/dev/null 2>&1 || exit 5
        else
          ping -c1 -W3 {{ host }} >/dev/null 2>&1 || exit 6
        fi
        {% endfor %}
        exit 0
      register: garage_test_tailscale_ping
      changed_when: false
      failed_when: false
      when: garage_test_mode_effective | bool

    - name: Show repeater diagnostics when test-mode uplink check fails
      ansible.builtin.raw: |
        echo "ifstatus {{ garage_test_repeater_network_effective }}:"
        ifstatus {{ garage_test_repeater_network_effective }} || true
        echo
        echo "wireless.sta:"
        uci show wireless.sta || true
        echo
        for r in {{ garage_test_repeater_radios_effective | join(' ') }}; do
          echo "scan summary for $r:"
          iwinfo "$r" scan 2>/dev/null | grep -E 'ESSID:|Encryption:' | head -n 60 || true
          echo
        done
      register: garage_test_repeater_diag
      changed_when: false
      failed_when: false
      when:
        - garage_test_mode_effective | bool
        - garage_test_tailscale_ping is defined
        - garage_test_tailscale_ping.rc != 0

    - name: Print repeater diagnostics summary when test-mode uplink check fails
      ansible.builtin.debug:
        msg: "{{ garage_test_repeater_diag.stdout | default('no diagnostics captured') }}"
      when:
        - garage_test_mode_effective | bool
        - garage_test_tailscale_ping is defined
        - garage_test_tailscale_ping.rc != 0

    - name: Fail when repeater test-mode uplink validation fails
      ansible.builtin.fail:
        msg: >-
          Test mode repeater uplink validation failed (rc={{ garage_test_tailscale_ping.rc }}).
          Review diagnostics from the previous task to identify matching radio/encryption.
      when:
        - garage_test_mode_effective | bool
        - garage_test_tailscale_ping is defined
        - garage_test_tailscale_ping.rc != 0

    - name: Test-mode check passed for tailscale control-plane reachability
      ansible.builtin.debug:
        msg: >-
          Test mode uplink can reach tailscale control-plane hosts:
          {{ garage_test_tailscale_hosts_effective | join(', ') }}.
          {{ garage_test_tailscale_ping.stdout | default('') }}
      when:
        - garage_test_mode_effective | bool
        - garage_test_tailscale_ping.rc == 0

    - name: Ensure tailscale packages are installed (best effort)
      ansible.builtin.raw: |
        if ! command -v tailscale >/dev/null 2>&1; then
          opkg update && opkg install kmod-tun tailscale
        fi
      when: tailscale_enable_effective | bool
      register: tailscale_install_result
      failed_when: false

    - name: Enable and start tailscale service (best effort)
      ansible.builtin.raw: |
        if command -v tailscale >/dev/null 2>&1; then
          /etc/init.d/tailscale enable
          /etc/init.d/tailscale restart || /etc/init.d/tailscale start
        fi
      when: tailscale_enable_effective | bool
      register: tailscale_service_result
      failed_when: false

    - name: Configure tailscale exit-node and route advertisements (best effort)
      ansible.builtin.raw: |
        if command -v tailscale >/dev/null 2>&1; then
          tailscale up \
            --hostname='router-garage' \
            --advertise-exit-node \
            --advertise-routes='{{ tailscale_advertise_routes_csv }}' \
            --accept-routes=true \
            --accept-dns=false
        fi
      when: tailscale_enable_effective | bool
      register: tailscale_up_result
      failed_when: false

    - name: Configure tailscale with auth key when required (best effort)
      ansible.builtin.raw: |
        if command -v tailscale >/dev/null 2>&1; then
          tailscale up \
            --auth-key='{{ tailscale_auth_key_effective }}' \
            --hostname='router-garage' \
            --advertise-exit-node \
            --advertise-routes='{{ tailscale_advertise_routes_csv }}' \
            --accept-routes=true \
            --accept-dns=false
        fi
      when:
        - tailscale_enable_effective | bool
        - tailscale_up_result is defined
        - tailscale_up_result.rc != 0
        - tailscale_auth_key_effective | length > 0
      register: tailscale_up_authkey_result
      failed_when: false
      no_log: true

    - name: Request tailscale OAuth access token (best effort)
      ansible.builtin.uri:
        url: "https://api.tailscale.com/api/v2/oauth/token"
        method: POST
        force_basic_auth: true
        url_username: "{{ tailscale_oauth_client_id_effective }}"
        url_password: "{{ tailscale_oauth_client_secret_effective }}"
        body_format: form-urlencoded
        body:
          grant_type: "client_credentials"
        return_content: true
        status_code: 200
      delegate_to: localhost
      become: false
      register: tailscale_oauth_token_result
      failed_when: false
      no_log: true
      when:
        - tailscale_enable_effective | bool
        - tailscale_up_result is defined
        - tailscale_up_result.rc != 0
        - tailscale_auth_key_effective | length == 0
        - tailscale_oauth_client_id_effective | length > 0
        - tailscale_oauth_client_secret_effective | length > 0

    - name: Create tailscale auth key from OAuth credentials (best effort)
      ansible.builtin.uri:
        url: "https://api.tailscale.com/api/v2/tailnet/{{ tailscale_oauth_tailnet_effective }}/keys"
        method: POST
        headers:
          Authorization: "Bearer {{ tailscale_oauth_token_result.json.access_token }}"
          Content-Type: "application/json"
        body_format: raw
        body: |
          {
            "capabilities": {
              "devices": {
                "create": {
                  "reusable": true,
                  "ephemeral": false,
                  "preauthorized": true,
                  "tags": {{ tailscale_oauth_tags_effective | to_json }}
                }
              }
            },
            "expirySeconds": {{ tailscale_oauth_key_expiry_seconds_effective | int }},
            "description": "ansible-router-garage-bootstrap"
          }
        return_content: true
        status_code:
          - 200
          - 201
      delegate_to: localhost
      become: false
      register: tailscale_oauth_key_result
      failed_when: false
      no_log: true
      when:
        - tailscale_enable_effective | bool
        - tailscale_oauth_token_result is defined
        - tailscale_oauth_token_result.status | default(0) == 200
        - tailscale_oauth_token_result.json.access_token is defined

    - name: Store generated tailscale auth key
      ansible.builtin.set_fact:
        tailscale_generated_auth_key_effective: "{{ tailscale_oauth_key_result.json.key | default('') }}"
      no_log: true
      when:
        - tailscale_oauth_key_result is defined
        - tailscale_oauth_key_result.status | default(0) in [200, 201]
        - tailscale_oauth_key_result.json.key is defined

    - name: Show tailscale OAuth key creation diagnostics (best effort)
      ansible.builtin.debug:
        msg: >-
          Tailscale OAuth key creation did not return a usable key.
          status={{ tailscale_oauth_key_result.status | default('unknown') }}
          response={{ tailscale_oauth_key_result.json | default(tailscale_oauth_key_result.content | default('no body')) }}
      when:
        - tailscale_enable_effective | bool
        - tailscale_up_result is defined
        - tailscale_up_result.rc != 0
        - tailscale_auth_key_effective | length == 0
        - tailscale_oauth_key_result is defined
        - tailscale_generated_auth_key_effective | length == 0

    - name: Configure tailscale with generated OAuth auth key (best effort)
      ansible.builtin.raw: |
        if command -v tailscale >/dev/null 2>&1; then
          tailscale up \
            --auth-key='{{ tailscale_generated_auth_key_effective }}' \
            --hostname='router-garage' \
            --advertise-exit-node \
            --advertise-routes='{{ tailscale_advertise_routes_csv }}' \
            --accept-routes=true \
            --accept-dns=false
        fi
      when:
        - tailscale_enable_effective | bool
        - tailscale_up_result is defined
        - tailscale_up_result.rc != 0
        - tailscale_auth_key_effective | length == 0
        - tailscale_generated_auth_key_effective | length > 0
      register: tailscale_up_oauth_key_result
      failed_when: false
      no_log: true

    - name: Show tailscale auth hint when not yet connected
      ansible.builtin.debug:
        msg: >-
          Tailscale is enabled but still needs authentication.
          Provide tailscale_auth_key in Vault, or provide
          vault_tailscale_oauth_client_id and
          vault_tailscale_oauth_client_secret in Vault, or run on router:
          tailscale up --hostname=router-garage --advertise-exit-node
          --advertise-routes='{{ tailscale_advertise_routes_csv }}'
      when:
        - tailscale_enable_effective | bool
        - tailscale_up_result is defined
        - tailscale_up_result.rc != 0
        - (tailscale_up_authkey_result.rc | default(1)) != 0
        - tailscale_generated_auth_key_effective | length == 0 or (tailscale_up_oauth_key_result.rc | default(1)) != 0

    - name: Verify WAN and internet reachability before disabling garage Wi-Fi
      ansible.builtin.raw: |
        if [ "{{ garage_test_mode_effective | ternary('true', 'false') }}" = "true" ]; then
          uplink_up="$(ifstatus {{ garage_test_repeater_network_effective }} 2>/dev/null | jsonfilter -e '@.up' 2>/dev/null || echo false)"
        else
          uplink_up="$(ifstatus wan 2>/dev/null | jsonfilter -e '@.up' 2>/dev/null || echo false)"
        fi
        if [ "$uplink_up" != "true" ]; then
          exit 2
        fi
        ping -c1 -W3 8.8.8.8 >/dev/null 2>&1 || ping -c1 -W3 1.1.1.1 >/dev/null 2>&1
      register: garage_wan_internet_check
      changed_when: false
      failed_when: false

    - name: Disable garage 2.4/5 GHz radios after WAN/internet confirmation
      ansible.builtin.raw: |
        {% for radio in garage_wifi_radios_to_disable_effective %}
        if uci -q get wireless.{{ radio }} >/dev/null 2>&1; then
          uci set wireless.{{ radio }}.disabled='1'
        fi
        {% endfor %}
      when:
        - not (garage_test_mode_effective | bool)
        - garage_wan_internet_check.rc == 0
        - garage_wifi_radios_to_disable_effective | length > 0

    - name: Commit wireless radio disable changes
      ansible.builtin.raw: |
        uci commit wireless
      when:
        - not (garage_test_mode_effective | bool)
        - garage_wan_internet_check.rc == 0
        - garage_wifi_radios_to_disable_effective | length > 0

    - name: Reload Wi-Fi after garage radio disable
      ansible.builtin.raw: |
        wifi reload >/dev/null 2>&1 || true
      when:
        - not (garage_test_mode_effective | bool)
        - garage_wan_internet_check.rc == 0
        - garage_wifi_radios_to_disable_effective | length > 0

    - name: Skip radio disable in garage test mode
      ansible.builtin.debug:
        msg: >-
          garage_test_mode is enabled; Wi-Fi radios are kept enabled so repeater
          uplink can provide internet for Tailscale during testing.
      when: garage_test_mode_effective | bool

    - name: Keep garage Wi-Fi enabled when WAN/internet not confirmed
      ansible.builtin.debug:
        msg: >-
          WAN/internet was not confirmed, so garage Wi-Fi radios were left enabled.
          Check ifstatus wan and upstream PPPoE link, then rerun to disable radios.
      when:
        - not (garage_test_mode_effective | bool)
        - garage_wan_internet_check.rc != 0
        - garage_wifi_radios_to_disable_effective | length > 0
