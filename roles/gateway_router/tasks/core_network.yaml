- name: Set router hostname and timezone
  ansible.builtin.raw: |
    uci set system.@system[0].hostname='gateway-router'
    uci set system.@system[0].zonename='Europe/London'
    uci set system.@system[0].timezone='GMT0BST,M3.5.0/1,M10.5.0'

- name: Rename gateway-router Wi-Fi SSIDs to management label
  ansible.builtin.raw: |
    idx=0
    while uci -q get wireless.@wifi-iface[$idx] >/dev/null 2>&1; do
      uci set wireless.@wifi-iface[$idx].ssid='{{ gateway_router_mgmt_ssid_effective }}'
      idx=$((idx+1))
    done

- name: Set LAN management interface
  ansible.builtin.raw: |
    uci set network.lan.ipaddr='{{ lan_ip }}'
    uci set network.lan.netmask='{{ lan_netmask }}'

- name: Configure WAN VLAN device for PPPoE
  ansible.builtin.raw: |
    current_wan_dev="$(uci -q get network.wan.device || true)"
    wan_parent='{{ gateway_router_wan_parent_if_effective }}'
    if [ -z "$wan_parent" ]; then
      if [ -n "$current_wan_dev" ]; then
        case "$current_wan_dev" in
          *.*) wan_parent="${current_wan_dev%%.*}" ;;
          *) wan_parent="$current_wan_dev" ;;
        esac
      else
        wan_parent='eth1'
      fi
    fi
    wan_vlan_dev="${wan_parent}.{{ gateway_router_wan_vlan_tag_effective }}"
    uci -q delete network.wan_vlan
    uci set network.wan_vlan='device'
    uci set network.wan_vlan.type='8021q'
    uci set network.wan_vlan.ifname="$wan_parent"
    uci set network.wan_vlan.vid='{{ gateway_router_wan_vlan_tag_effective }}'
    uci set network.wan_vlan.name="$wan_vlan_dev"
    uci set network.wan.device="$wan_vlan_dev"
  when:
    - gateway_router_wan_proto_effective == "pppoe"
    - not (gateway_router_test_mode_effective | bool)

- name: Configure WAN PPPoE credentials and behavior
  ansible.builtin.raw: |
    uci set network.wan.proto='pppoe'
    uci set network.wan.username='{{ gateway_router_wan_pppoe_username_effective }}'
    uci set network.wan.password='{{ gateway_router_wan_pppoe_password_effective }}'
    uci set network.wan.mtu='{{ gateway_router_wan_pppoe_mtu_effective }}'
    uci set network.wan.ipv6='auto'
    uci set network.wan.peerdns='1'
    {% if gateway_router_wan_pppoe_service_effective | length > 0 %}
    uci set network.wan.service='{{ gateway_router_wan_pppoe_service_effective }}'
    {% endif %}
  when:
    - gateway_router_wan_proto_effective == "pppoe"
    - not (gateway_router_test_mode_effective | bool)
  no_log: true

- name: Configure test-mode repeater uplink (Wi-Fi WAN)
  ansible.builtin.raw: |
    uci -q delete network.{{ gateway_router_test_repeater_network_effective }}
    uci set network.{{ gateway_router_test_repeater_network_effective }}='interface'
    uci set network.{{ gateway_router_test_repeater_network_effective }}.proto='dhcp'
    uci set network.{{ gateway_router_test_repeater_network_effective }}.peerdns='1'
    uci set network.{{ gateway_router_test_repeater_network_effective }}.metric='10'

    ssid={{ gateway_router_test_repeater_ssid_effective | quote }}
    wifi_devices="$(uci -q show wireless | sed -n "s/^wireless\\.\\([^.=]*\\)=wifi-device$/\\1/p")"
    dev_2g=''
    dev_5g=''
    dev_6g=''
    for dev in $wifi_devices; do
      band="$(uci -q get wireless."$dev".band || true)"
      case "$band" in
        2g) [ -z "$dev_2g" ] && dev_2g="$dev" ;;
        5g) [ -z "$dev_5g" ] && dev_5g="$dev" ;;
        6g) [ -z "$dev_6g" ] && dev_6g="$dev" ;;
      esac
    done
    resolve_radio() {
      requested="${1:-}"
      [ -n "$requested" ] || return 1
      if uci -q get wireless."$requested" >/dev/null 2>&1; then
        printf '%s\n' "$requested"
        return 0
      fi
      case "$requested" in
        radio0) [ -n "$dev_2g" ] && printf '%s\n' "$dev_2g" && return 0 ;;
        radio1) [ -n "$dev_5g" ] && printf '%s\n' "$dev_5g" && return 0 ;;
        radio2) [ -n "$dev_6g" ] && printf '%s\n' "$dev_6g" && return 0 ;;
      esac
      return 1
    }

    selected_radio="$(resolve_radio '{{ gateway_router_test_repeater_radio_effective }}' || true)"
    for radio in {{ gateway_router_test_repeater_radios_effective | join(' ') }}; do
      resolved_radio="$(resolve_radio "$radio" || true)"
      [ -n "$resolved_radio" ] || continue
      if iwinfo "$resolved_radio" scan 2>/dev/null | grep -F "ESSID: \"$ssid\"" >/dev/null 2>&1; then
        selected_radio="$resolved_radio"
        break
      fi
    done
    if [ -z "$selected_radio" ] || ! uci -q get wireless."$selected_radio" >/dev/null 2>&1; then
      for radio in {{ gateway_router_test_repeater_radios_effective | join(' ') }}; do
        resolved_radio="$(resolve_radio "$radio" || true)"
        if [ -n "$resolved_radio" ] && uci -q get wireless."$resolved_radio" >/dev/null 2>&1; then
          selected_radio="$resolved_radio"
          break
        fi
      done
    fi
    if [ -z "$selected_radio" ] || ! uci -q get wireless."$selected_radio" >/dev/null 2>&1; then
      selected_radio="$(printf '%s\n' "$wifi_devices" | head -n 1)"
    fi
    if ! uci -q get wireless."$selected_radio" >/dev/null 2>&1; then
      echo "No usable wifi-device section found in wireless UCI config."
      uci -q show wireless || true
      exit 11
    fi

    uci set wireless."$selected_radio".disabled='0'
    uci -q delete wireless.sta
    uci set wireless.sta='wifi-iface'
    uci set wireless.sta.device="$selected_radio"
    uci set wireless.sta.mode='sta'
    uci set wireless.sta.network='{{ gateway_router_test_repeater_network_effective }}'
    uci set wireless.sta.ssid={{ gateway_router_test_repeater_ssid_effective | quote }}
    scan_encryption=''
    scan_line="$(iwinfo "$selected_radio" scan 2>/dev/null | awk '
      BEGIN { found=0 }
      /ESSID: / {
        if (index($0, "\"{{ gateway_router_test_repeater_ssid_effective }}\"") > 0) {
          found=1
        } else {
          found=0
        }
      }
      found && /Encryption:/ {
        print
        exit
      }
    ' || true)"
    if printf '%s\n' "$scan_line" | grep -qi 'WPA3'; then
      scan_encryption='sae'
    elif printf '%s\n' "$scan_line" | grep -qi 'WPA2'; then
      scan_encryption='psk2'
    fi

    selected_encryption='{{ gateway_router_test_repeater_encryption_effective }}'
    if [ -n "$scan_encryption" ]; then
      selected_encryption="$scan_encryption"
    fi

    fallback_encryptions='{{ gateway_router_test_repeater_encryptions_effective | join(" ") }}'
    if [ -n "$fallback_encryptions" ] && ! printf '%s\n' "$fallback_encryptions" | tr ' ' '\n' | grep -Fx "$selected_encryption" >/dev/null 2>&1; then
      selected_encryption="$(printf '%s\n' "$fallback_encryptions" | awk '{print $1}')"
    fi

    uci set wireless.sta.encryption="$selected_encryption"
    uci set wireless.sta.disabled='0'
    uci -q delete wireless.sta.wds

    idx=0
    while uci -q get firewall.@zone[$idx] >/dev/null 2>&1; do
      if [ "$(uci -q get firewall.@zone[$idx].name)" = "wan" ]; then
        uci -q del_list firewall.@zone[$idx].network='{{ gateway_router_test_repeater_network_effective }}'
        uci add_list firewall.@zone[$idx].network='{{ gateway_router_test_repeater_network_effective }}'
        break
      fi
      idx=$((idx+1))
    done
  when: gateway_router_test_mode_effective | bool

- name: Configure test-mode repeater password (secret)
  ansible.builtin.raw: |
    uci set wireless.sta.key={{ gateway_router_test_repeater_password_effective | quote }}
  when: gateway_router_test_mode_effective | bool
  no_log: true

- name: Configure bridge VLAN filtering and trunk tagging on gateway LAN bridge
  ansible.builtin.raw: |
    br_idx=''
    idx=0
    while uci -q get network.@device[$idx] >/dev/null 2>&1; do
      if [ "$(uci -q get network.@device[$idx].name)" = 'br-lan' ]; then
        br_idx="$idx"
        break
      fi
      idx=$((idx+1))
    done

    if [ -z "$br_idx" ]; then
      echo "Unable to locate br-lan device section in UCI network config." >&2
      exit 12
    fi

    uci set network.@device[$br_idx].vlan_filtering='1'

    # Remove prior bridge-vlan entries for a clean, idempotent rebuild.
    idx=0
    while uci -q get network.@bridge-vlan[$idx] >/dev/null 2>&1; do
      uci -q delete network.@bridge-vlan[$idx]
    done

    lan_ports=''
    uci_ports="$(uci -q get network.@device[$br_idx].ports 2>/dev/null | tr '\n' ' ' || true)"
    if [ -n "$uci_ports" ]; then
      lan_ports="$uci_ports"
    fi

    if [ -z "$lan_ports" ]; then
      runtime_ports="$(bridge link show master br-lan 2>/dev/null | awk -F': ' '/^[0-9]+: / {split($2, a, " "); sub(/@.*/, "", a[1]); if (a[1] != "br-lan") print a[1]}' | tr '\n' ' ')"
      if [ -n "$runtime_ports" ]; then
        lan_ports="$runtime_ports"
        uci -q delete network.@device[$br_idx].ports
        for port in $lan_ports; do
          uci add_list network.@device[$br_idx].ports="$port"
        done
      fi
    fi

    if [ -z "$lan_ports" ]; then
      echo "br-lan has no configured member ports." >&2
      exit 13
    fi

    uci add network bridge-vlan >/dev/null
    uci set network.@bridge-vlan[-1].device='br-lan'
    uci set network.@bridge-vlan[-1].vlan='{{ gateway_router_lan_management_vlan_effective }}'
    for port in $lan_ports; do
      uci add_list network.@bridge-vlan[-1].ports="$port:u*"
    done

    {% for vlan in network_vlans_effective if (vlan.id | int) != (gateway_router_lan_management_vlan_effective | int) %}
    uci add network bridge-vlan >/dev/null
    uci set network.@bridge-vlan[-1].device='br-lan'
    uci set network.@bridge-vlan[-1].vlan='{{ vlan.id }}'
    for port in $lan_ports; do
      uci add_list network.@bridge-vlan[-1].ports="$port:t"
    done
    {% endfor %}

- name: Ensure VLAN interfaces exist
  ansible.builtin.raw: |
    {% for vlan in network_vlans_effective if (vlan.id | int) != (gateway_router_lan_management_vlan_effective | int) %}
    uci -q delete network.vlan{{ vlan.id }}
    uci set network.vlan{{ vlan.id }}='interface'
    uci set network.vlan{{ vlan.id }}.proto='static'
    uci set network.vlan{{ vlan.id }}.device='br-lan.{{ vlan.id }}'
    uci set network.vlan{{ vlan.id }}.ipaddr='{{ vlan.ip }}'
    uci set network.vlan{{ vlan.id }}.netmask='255.255.255.0'
    {% endfor %}

- name: Ensure DHCP pools exist for routed VLANs
  ansible.builtin.raw: |
    {% for vlan in network_vlans_effective if (vlan.id | int) != (gateway_router_lan_management_vlan_effective | int) %}
    uci -q delete dhcp.vlan{{ vlan.id }}
    uci set dhcp.vlan{{ vlan.id }}='dhcp'
    uci set dhcp.vlan{{ vlan.id }}.interface='vlan{{ vlan.id }}'
    uci set dhcp.vlan{{ vlan.id }}.start='100'
    uci set dhcp.vlan{{ vlan.id }}.limit='150'
    uci set dhcp.vlan{{ vlan.id }}.leasetime='12h'
    {% endfor %}

- name: Configure firewall zones for VLANs
  ansible.builtin.raw: |
    {% for vlan in network_vlans_effective if (vlan.id | int) != (gateway_router_lan_management_vlan_effective | int) %}
    uci -q delete firewall.{{ vlan.zone }}
    uci set firewall.{{ vlan.zone }}='zone'
    uci set firewall.{{ vlan.zone }}.name='{{ vlan.zone }}'
    uci set firewall.{{ vlan.zone }}.network='vlan{{ vlan.id }}'
    uci set firewall.{{ vlan.zone }}.input='{{ 'ACCEPT' if vlan.name in ['servers', 'trusted'] else 'REJECT' }}'
    uci set firewall.{{ vlan.zone }}.output='ACCEPT'
    uci set firewall.{{ vlan.zone }}.forward='{{ 'ACCEPT' if vlan.name == 'servers' else 'REJECT' }}'
    {% endfor %}

- name: Configure inter-zone forwarding rules from vars
  ansible.builtin.raw: |
    idx=0
    while uci -q get firewall.forwarding[$idx] >/dev/null 2>&1; do
      uci -q delete firewall.forwarding[$idx]
    done
    {% for rule in network_forwarding_rules_effective %}
    uci add firewall forwarding >/dev/null
    uci set firewall.@forwarding[-1].src='{{ rule.src }}'
    uci set firewall.@forwarding[-1].dest='{{ rule.dest }}'
    {% endfor %}

- name: Add trusted to servers limited management rule
  ansible.builtin.raw: |
    uci -q delete firewall.trusted_to_servers_mgmt
    uci set firewall.trusted_to_servers_mgmt='rule'
    uci set firewall.trusted_to_servers_mgmt.name='Trusted to Servers Web and SSH'
    uci set firewall.trusted_to_servers_mgmt.src='trusted_zone'
    uci set firewall.trusted_to_servers_mgmt.dest='server_zone'
    uci set firewall.trusted_to_servers_mgmt.proto='tcp'
    uci set firewall.trusted_to_servers_mgmt.dest_port='22 80 443'
    uci set firewall.trusted_to_servers_mgmt.target='ACCEPT'

- name: Commit core UCI changes
  ansible.builtin.raw: |
    uci commit system
    uci commit network
    uci commit dhcp
    uci commit firewall
    uci commit wireless

- name: Restart firewall and dnsmasq before LAN IP handoff
  ansible.builtin.raw: |
    /etc/init.d/dnsmasq restart || /etc/init.d/dnsmasq start
    /etc/init.d/firewall restart

- name: Apply delayed network and Wi-Fi reload for safer SSH handoff
  ansible.builtin.raw: |
    nohup sh -c "sleep 2; /etc/init.d/network reload; wifi reload >/dev/null 2>&1 || true" >/dev/null 2>&1 &

- name: Wait for SSH on post-change management IP (best effort)
  ansible.builtin.wait_for:
    host: "{{ lan_ip }}"
    port: 22
    delay: 4
    timeout: 90
  delegate_to: localhost
  become: false
  register: gateway_router_handoff_wait
  failed_when: false
  changed_when: false

- name: Show reconnection hint
  ansible.builtin.debug:
    msg: >-
      If your control host route changed during reload, reconnect using
      ssh root@{{ lan_ip }} and rerun with -e ansible_host=192.168.8.1 for
      future factory-reset bootstrap runs.

- name: Reset SSH control connection after delayed reload (test mode)
  ansible.builtin.meta: reset_connection

- name: Wait for SSH port after control-connection reset (test mode)
  ansible.builtin.wait_for:
    host: "{{ lan_ip }}"
    port: 22
    delay: 2
    timeout: 90
  delegate_to: localhost
  become: false
  changed_when: false
  when: gateway_router_test_mode_effective | bool
